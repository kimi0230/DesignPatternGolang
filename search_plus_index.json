{"./":{"url":"./","title":"Introduction","keywords":"","body":"設計模式 (Design Pattern) 基於 程杰-大話設計模式 和 Design Patterns: Elements of Reusable Object-Oriented Software. 使用 Golang 來實現 https://kimi0230.github.io/DesignPatternGolang/ 生成模式 (Creational Patterns) 牽涉到將物件實體化。這類模式都提供一個方法，將客戶從所需要實體化的物件中鬆綁出來 Factory Method 工廠模式： go 定義可滋生成物件的介面, 但讓子類別去決定該具現出哪一種類別的物件. 此模式讓類別將具現化程序交給子類別去處置 Prototype 原型模式： go 制定可用原型個體生成的物件類型, 爾後只需複製此原型即可生成新物件 Builder 建造者模式： go 從複雜物件的佈局中抽取出生成程序, 以便用同一個生成程序製造各種不同的物件佈局 Abstract Factory 抽象工廠模式： go 以同一個介面來建立一整組相關或相依的物件, 不需要點名個物件真正所屬的具象類別 Singleton 獨體模式： go 確保類別只會有一個物件實體存在, 並提供單一存取窗口 結構模式 (Structural Patterns) 讓你合成類別或物件到大型的結構 Decorator 裝飾模式： go 將額外權責動態附加於物件身上, 不必衍生子類別即可彈性擴增功能 Proxy 代理模式： go 替其他物件預留代理者空位, 就此控制存取其他物件 Facade 外觀模式： go 替子系統裡的一堆介面定義一套統一的高階介面, 讓子系統更容易使用 Adapter 轉接器模式： go 將類別的介面轉換成外界所預期的另一種介面, 讓原先囿於見面不相容問題而無法協力合作的類別能夠兜在一起用 Composite 組合模式： go 將物件組織成樹狀結構, 部分-全體 層級關係, 讓外界以一致性的方式對待個別物件和整體物件 Bridge 橋接模式： go 將實作體系與抽象體系分離開來, 讓兩者能各自更動各自演進 Flyweight 享元模式： go 以共享機制有效地支援一大堆小規模的物件 行為模式 (Behavioral Patterns) 模述類別和物件如何互動，以及各自的責任 Strategy 策略模式： go 定義一整組演算法, 講每一個演算法封裝起來, 可互換使用, 更可在不影響外界的情況下個別抽換所以引用的演算法 Template Method 範本方式模式: go 對於操作, 只先定義好演算法的輪廓, 某些步驟則留給子類別去填飽, 以便在不改變演算法整體構造的情況下讓子類別去精煉某些步驟 Observer 觀察者模式: go 定義一對多的物件依存關係, 讓物件狀態一有變動, 就自動通知其他相依物件做該做的更新動作 State 狀態模式: go 讓物件的外顯行為隨內部狀態的改變而改變, 彷彿連類別也變了似的 Memento 備忘錄模式: go 在不違反封裝性的前提下, 捕捉物件的內部狀態並存在外面,以便日後回復至此一狀態 Iterator 迭代器模式: go 無需知曉聚合物件的內部細節, 即可依序存取內含的每一個元素 Command 命令模式: go 將訊息封裝成物件, 以便能用各種不同訊息, 暫佇, 紀律, 復原等方式加以參數化處理 Chain of Responsibility 職責鏈模式: go 讓多個物件都有機會處理某一訊息, 以降低訊息發送者和接收者之間的耦合關係. 它將接收者物件串連起來, 讓訊息流經其中,直到被處理了為止 Mediator 仲介者模式: go 定義可將一群物件互動方式封裝起來的物件. 因為物件彼此不直接相互指涉, 所以耦合性低, 容易逐一變更互動關係 Interpreter 解譯器模式: go 針對標的語言定義文法, 以及可解讀這個語句的解譯器 Visitor 訪問者模式: go 定義能逐一施行於物件結構裡各個元素的操作, 讓你不必修改作用對象的類別介面, 就能定義新的操作 © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"AbstractFactory/":{"url":"AbstractFactory/","title":"Abstract Factory","keywords":"","body":"Abstract Factory 抽象工廠模式: 以同一個介面來建立一整組相關或相依的物件, 不需要點名個物件真正所屬的具象類別 提供一個建立一系列相關或相互一類物件的介面, 而無需指名他們具體的類別 像是一個集團下有不同的工廠可以生成不同的產品, 每個工廠稱產出來的同一個型號產品具體細節是不一樣 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/AbstractFactory package abstractfactory import \"fmt\" type User struct { id int name string } func (u *User) Id() int { if u == nil { return -1 } return u.id } func (u *User) SetId(id int) { if u == nil { return } u.id = id } func (u *User) Name() string { if u == nil { return \"\" } return u.name } func (u *User) SetName(name string) { if u == nil { return } u.name = name } type Department struct { id int name string } func (d *Department) Id() int { if d == nil { return -1 } return d.id } func (d *Department) SetId(id int) { if d == nil { return } d.id = id } func (d *Department) Name() string { if d == nil { return \"\" } return d.name } func (d *Department) SetName(name string) { if d == nil { return } d.name = name } type IUser interface { Insert(*User) GetUser(int) *User } type SqlServerUser struct { } func (s *SqlServerUser) Insert(u *User) { if s == nil { return } fmt.Println(\"在 Sql Server 中給 User insert 一筆紀錄\", u) } func (s *SqlServerUser) GetUser(id int) (u *User) { if s == nil { return nil } u = &User{id, \"kk\"} fmt.Println(\"在 Sql Server 中根據 id 得到 User 紀錄\", *u) return u } type AccessUser struct { } func (a *AccessUser) Insert(u *User) { if a == nil { return } fmt.Println(\"在 Access 中給 Department insert 一筆紀錄\", *u) } func (a *AccessUser) GetUser(id int) (u *User) { if a == nil { return nil } u = &User{id, \"kk\"} fmt.Println(\"在 Access 中根據 id 得到 User 紀錄\", *u) return u } // 用於用戶端存取 解除與具體資料庫存取的耦合 type IDepartment interface { Insert(*Department) GetDepartment(int) *Department } // 用於存取 SQL server的 Department type SqlServerDepartment struct { } func (s *SqlServerDepartment) Insert(d *Department) { if s == nil { return } fmt.Println(\"在 Sql Server 中給 Department insert 一筆紀錄\", *d) } func (s *SqlServerDepartment) GetDepartment(id int) (d *Department) { if s == nil { return nil } d = &Department{id, \"dd\"} fmt.Println(\"在 Sql Server 中根據 id 得到 Department 紀錄\", *d) return d } // 用於存取 Access的 Department type AccessDepartment struct { } func (a *AccessDepartment) Insert(d *Department) { if a == nil { return } fmt.Println(\"在 Access 中給 Department insert 一筆紀錄\", *d) } func (a *AccessDepartment) GetDepartment(id int) (d *Department) { if a == nil { return nil } d = &Department{id, \"dd\"} fmt.Println(\"在 Access 中根據 id 得到 Department 紀錄\", *d) return d } // 定義一個建立存取 User, Department 物件的抽象工廠介面 type IFactory interface { CreateUser() IUser CreateDepartment() IDepartment } // 實現 IFactory 介面 type SqlServerFactory struct{} func (s *SqlServerFactory) CreateUser() IUser { if s == nil { return nil } u := &SqlServerUser{} return u } func (s *SqlServerFactory) CreateDepartment() IDepartment { if s == nil { return nil } d := &SqlServerDepartment{} return d } // 實現 IFactory 介面 type AccessFactory struct{} func (a *AccessFactory) CreateUser() IUser { if a == nil { return nil } u := &AccessUser{} return u } func (a *AccessFactory) CreateDepartment() IDepartment { if a == nil { return nil } d := &AccessDepartment{} return d } // 用簡單工廠來改進抽象工廠 type DataAccess struct { db string } func (d *DataAccess) CreateUser() IUser { if d == nil { return nil } var u IUser if d.db == \"sqlserver\" { u = new(SqlServerUser) } else if d.db == \"access\" { u = new(AccessUser) } return u } func (d *DataAccess) CreateDepartment() IDepartment { if d == nil { return nil } var u IDepartment if d.db == \"sqlserver\" { u = new(SqlServerDepartment) } else if d.db == \"access\" { u = new(AccessDepartment) } return u } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Adapter/":{"url":"Adapter/","title":"Adapter","keywords":"","body":"Adapter 轉接器模式: 將類別的介面轉換成外界所預期的另一種介面, 讓原先囿於見面不相容問題而無法協力合作的類別能夠兜在一起用 將一個類別的介面轉換成客戶希望的另外一個介面, Adapter 模式始原本由於介面不相容而不能一起工作的那些類別可以一起工作 與 Proxy 代理模式相似 Proxy 代理模式: 使用介面, 客戶端不知道代理對象 Adapter 轉接器模式: 可以是具體或抽象類別,或是介面, 對象的接口和客户端想要的不一樣, Adapter將接口封装一下, 改成客戶端想要的接口 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Adapter package adapter import \"fmt\" // Player : target type Player interface { Attack() Defense() } // 前鋒 type Forwards struct { Name string } func (p *Forwards) Attack() { if p == nil { return } fmt.Printf(\"前鋒 %s 進攻 \\n\", p.Name) } func (p *Forwards) Defense() { if p == nil { return } fmt.Printf(\"前鋒 %s 防守 \\n\", p.Name) } func NewForwards(name string) Player { return &Forwards{name} } // 中鋒 type Center struct { Name string } func (p *Center) Attack() { if p == nil { return } fmt.Printf(\"中鋒 %s 進攻 \\n\", p.Name) } func (p *Center) Defense() { if p == nil { return } fmt.Printf(\"中鋒 %s 防守 \\n\", p.Name) } func NewCenter(name string) Player { return &Center{name} } // 後衛 type Guards struct { Name string } func (p *Guards) Attack() { if p == nil { return } fmt.Printf(\"後衛 %s 進攻 \\n\", p.Name) } func (p *Guards) Defense() { if p == nil { return } fmt.Printf(\"後衛 %s 防守 \\n\", p.Name) } func NewGuards(name string) Player { return &Guards{name} } // 外籍中鋒 : Adaptee type ForeignCenter struct { Name string } func (p *ForeignCenter) AttackYo() { if p == nil { return } fmt.Printf(\"外籍中鋒 %s 進攻yo \\n\", p.Name) } func (p *ForeignCenter) DefenseYo() { if p == nil { return } fmt.Printf(\"外籍中鋒 %s 防守yo \\n\", p.Name) } // Translator : Adapter type Translator struct { f ForeignCenter } func (t *Translator) Attack() { if t == nil { return } t.f.AttackYo() } func (t *Translator) Defense() { if t == nil { return } t.f.DefenseYo() } func NewTranslator(name string) Player { return &Translator{ForeignCenter{name}} } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Bridge/":{"url":"Bridge/","title":"Bridge","keywords":"","body":"Bridge 橋接模式： 將實作體系與抽象體系分離開來, 讓兩者能各自更動各自演進 將抽象部分與他的實現部分分離, 使他們都可以獨立低變化 合成/聚合復用原則: 盡量使用合成/聚合, 不要使用類別繼承 聚合表示一種弱的擁有關係, 表現是的是 A 物件可以包涵 B 物件, 但 B 物件不是 A 物件的一部分; ex: 雁群/雁, 在雁群類別中有雁陣列物件 合成則是一種強的擁有關係, 表現了嚴格的部分和整體的關係, 部分和整體的生命週期一樣 ex: 鳥/翅膀, 在鳥類別中初始化時, 實體翅膀同時產生 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Bridge package bridge import \"fmt\" // HandsetSoft: 手機軟體 Implementor type HandsetSoft interface { Run() } // HandsetGame : 手機遊戲 ConcreteImplementorA type HandsetGame struct{} func (h *HandsetGame) Run() { fmt.Println(\"執行手機遊戲\") } // HandsetAddressList : 手機通訊錄 ConcreteImplementorB type HandsetAddressList struct { } func (h *HandsetAddressList) Run() { fmt.Println(\"執行手機通訊錄\") } // HandsetBrand : 手機品牌 Abstraction type HandsetBrand interface { SetHandsetSoft(HandsetSoft) Run() } // HandsetBrandN : RefinedAbstraction type HandsetBrandN struct { soft HandsetSoft } func (h *HandsetBrandN) SetHandsetSoft(software HandsetSoft) { if h == nil { return } h.soft = software } func (h *HandsetBrandN) Run() { if h == nil { return } h.soft.Run() } // HandsetBrandM : RefinedAbstraction type HandsetBrandM struct { soft HandsetSoft } func (h *HandsetBrandM) SetHandsetSoft(software HandsetSoft) { if h == nil { return } h.soft = software } func (h *HandsetBrandM) Run() { if h == nil { return } h.soft.Run() } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Builder/":{"url":"Builder/","title":"Builder","keywords":"","body":"Builder 建造者模式: 從複雜物件的佈局中抽取出生成程序, 以便用同一個生成程序製造各種不同的物件佈局 將一個複雜物件的構建與他的表示分離, 使得同樣的構建過程可以建立不同的表示 建造者的建造流程是在指揮者(Director)中，指揮者在用戶通知他現在具體的建造者是誰後， 建造出對應的產品，建造者中實現了產品的建造細節 來源: 程杰-大話設計模式 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Builder package builder import \"fmt\" // 產品類別, 由多個零件組成 type Product struct { parts []string } func (p *Product) Add(part string) { p.parts = append(p.parts, part) } func (p *Product) Show() { fmt.Println(p.parts) } type Builder interface { BuildPartA() BuildPartB() GetResult() *Product } // 具體建造者 實現Builder interface 構造和裝配各個零件 type ConcreteBuilder1 struct { product Product } func (c *ConcreteBuilder1) BuildPartA() { c.product.Add(\"零件A\") } func (c *ConcreteBuilder1) BuildPartB() { c.product.Add(\"零件B\") } func (c *ConcreteBuilder1) GetResult() *Product { return &c.product } // 具體建造者 type ConcreteBuilder2 struct { product Product } func (c *ConcreteBuilder2) BuildPartA() { c.product.Add(\"零件X\") } func (c *ConcreteBuilder2) BuildPartB() { c.product.Add(\"零件Y\") } func (c *ConcreteBuilder2) GetResult() *Product { return &c.product } // 是建構一個使用 Builder介面的物件 type Director struct { b Builder } func (d *Director) Construct() { d.b.BuildPartA() d.b.BuildPartB() } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"ChainofResponsibility/":{"url":"ChainofResponsibility/","title":"Chainof Responsibility","keywords":"","body":"Chain of Responsibility 職責鏈模式: 讓多個物件都有機會處理某一訊息, 以降低訊息發送者和接收者之間的耦合關係. 它將接收者物件串連起來, 讓訊息流經其中\b, 直到被處理了為止 使多個物件都有機會處理請求, 從而避免請求的發送者和接收者之間的耦合關係. 將這個物件連成一條鏈, 並沿著這條鏈傳遞該請求, 直到有一個物件處理它為止 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/ChainofResponsibility package chainofresponsibility import \"fmt\" type IHandler interface { SetSuccessor(IHandler) HandleRequest(int) } type Handler struct { successor IHandler // 繼任者 } // SetSuccessor : 設定繼任者 func (h *Handler) SetSuccessor(i IHandler) { if h == nil { return } h.successor = i } // 請求數在0~10之間則有權處理, 否則轉到下一位 type ConcreteHandler1 struct { Name string Handler } func NewConcreteHandler1(name string) *ConcreteHandler1 { return &ConcreteHandler1{name, Handler{}} } func (c *ConcreteHandler1) HandleRequest(req int) { if c == nil { return } if req >= 0 && req = 10 && req = 20 && req © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Command/":{"url":"Command/","title":"Command","keywords":"","body":"Command 命令模式: 將訊息封裝成物件, 以便能用各種不同訊息, 暫佇, 紀律, 復原等方式加以參數化處理 將一個請求封裝為一個物件, 讓你可以用不同的請求對客戶進行參數化; 對請求排隊或紀錄請求日誌, 以及支援可取消的操作 不要為程式碼加上基於猜測的, 實際上不需要的功能. 如果不清楚一個系統是否需要命令模式, 就不要急著實現它. 事實上, 在需要的時候透過重構實現這個模式並不難, 只有在真正需要如取消/恢復等功能時, 把原本的程式碼重構為命令模式才有意義 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Command package command import ( \"fmt\" \"time\" ) // Waiter : Invoker type Waiter struct { orders []Command } func (w *Waiter) SetOrder(c Command) { if w == nil { return } w.orders = append(w.orders, c) fmt.Printf(\"增加訂單: %s, 時間: %s \\n\", c.ToString(), time.Now().UTC().String()) } func (w *Waiter) CancelOrder(c Command) { if w == nil { return } for i := 0; i © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Composite/":{"url":"Composite/","title":"Composite","keywords":"","body":"Composite 組合模式： 將物件組織成樹狀結構, 部分-全體 層級關係, 讓外界以一致性的方式對待個別物件和整體物件 將物件組合成樹形結構以表示 部分-整體的層次結構. 組合模式使得用戶對單個物件和組合物件的使用具有一致性 何時使用組合模式 需求中是表現部分與整體曾是的結構時, 以及你希望用戶可以忽略組合物件與單個物件的不同, 統一地使用組合結構中的所有物件時, 就應該考慮組合模式. Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Composite package composite import ( \"fmt\" \"strings\" ) // Company : Component type Company interface { Add(Company) Remove(Company) Display(int) LineOfDuty() } type RealCompany struct { name string } // ConcreteCompany : Composite type ConcreteCompany struct { RealCompany children []Company } func NewConcreteCompany(name string) *ConcreteCompany { return &ConcreteCompany{RealCompany{name}, []Company{}} } func (c *ConcreteCompany) Add(com Company) { if c == nil { return } c.children = append(c.children, com) } func (c *ConcreteCompany) Remove(com Company) { if c == nil { return } for i, v := range c.children { if v == com { c.children = append(c.children[:i], c.children[i+1:]...) return } } return } func (c *ConcreteCompany) Display(depth int) { if c == nil { return } fmt.Println(strings.Repeat(\" \", depth-1), \"|--\", c.name) for _, v := range c.children { v.Display(depth + 2) } } func (c *ConcreteCompany) LineOfDuty() { if c == nil { return } for _, v := range c.children { v.LineOfDuty() } } // HR type HRDepartment struct { RealCompany } func NewHRDepartment(name string) *HRDepartment { return &HRDepartment{RealCompany{name}} } func (h *HRDepartment) Add(c Company) {} func (h *HRDepartment) Remove(c Company) {} func (h *HRDepartment) Display(depth int) { if h == nil { return } fmt.Println(strings.Repeat(\" \", depth-1), \"|--\", h.name) } func (h *HRDepartment) LineOfDuty() { if h == nil { return } fmt.Println(h.name, \"員工招聘教育訓練管理\") } // 財務部 type FinanceDepartment struct { RealCompany } func NewFinanceDepartment(name string) *FinanceDepartment { return &FinanceDepartment{RealCompany{name}} } func (f *FinanceDepartment) Add(c Company) {} func (f *FinanceDepartment) Remove(c Company) {} func (f *FinanceDepartment) Display(depth int) { if f == nil { return } fmt.Println(strings.Repeat(\" \", depth-1), \"|--\", f.name) } func (f *FinanceDepartment) LineOfDuty() { if f == nil { return } fmt.Println(f.name, \"公司財務收支管理\") } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Decorator/":{"url":"Decorator/","title":"Decorator","keywords":"","body":"Decorator 裝飾模式： 將額外權責動態附加於物件身上, 不必衍生子類別即可彈性擴增功能 將一個物件包裝起來, 以提供新的行為 將額外權責動態附加於物件身上, 不必衍生子類別即可彈性擴增功能 動態低給一個物件加入一些額外的職責, 就增加功能來說, 裝飾模式比產生子類別更為靈活 所有 decorator 在操作時需使用函數, 裝飾者順序很重要, 比如加密資料和過濾辭彙都可以是資料持久化前的裝飾功能 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Decorator /* Decorator 裝飾模式： 將一個物件包裝起來, 以提供新的行為 將額外權責動態附加於物件身上, 不必衍生子類別即可彈性擴增功能 動態低給一個物件加入一些額外的職責, 就增加功能來說, 裝飾模式比產生子類別更為靈活 所有 decorator 在操作時需使用函數, 裝飾者順序很重要, 比如加密資料和過濾辭彙都可以是資料持久化前的裝飾功能 */ package decorator import \"fmt\" // Person : concrete component type Person struct { Name string } func (p *Person) show() { if p == nil { return } fmt.Println(\"裝扮的\", p.Name) } // 服飾類別 Decorator // Finery : Decorator type Finery interface { show() } type Decorator struct { Finery } func (d *Decorator) SetDecorator(component Finery) { if d == nil { return } d.Finery = component } func (d *Decorator) show() { if d == nil { return } if d.Finery != nil { d.Finery.show() } } // 具體服飾類別 Concrete Decorator type TShirts struct { Decorator } func (t *TShirts) show() { if t == nil { return } fmt.Println(\"大T恤\") t.Decorator.show() } type BigTrouser struct { Decorator } func (b *BigTrouser) show() { if b == nil { return } fmt.Println(\"垮褲\") b.Decorator.show() } type Sneakers struct { Decorator } func (s *Sneakers) show() { if s == nil { return } s.Decorator.show() fmt.Println(\"破球鞋\") } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Facade/":{"url":"Facade/","title":"Facade","keywords":"","body":"Facade 外觀模式： 替子系統裡的一堆介面定義一套統一的高階介面, 讓子系統更容易使用 為子系統中的一組介面提供一個一致的界面，此模式定義了一個高層介面， 這個介面使得這一子系統更加容易使用（投資：基金，股票，房產） 外觀 vs. 轉接器 外觀定義的是一個新的介面, 為現存系統停工一個更為方便的存取介面; 轉接則是復用一個原有的介面, 轉接器是使兩個已有的介面協同工作 外觀模式用來轉接整個子系統, 轉接用來轉接物件 外觀 vs. Mediator 中介者模式、 外觀模式：外觀中保存了一堆對象,這些對像或者是組成某個子系統的, 將其封裝在外觀對像中,給客戶端一種只有一個對象的感覺, 中介者模式: 每個對像都保存一份中介者對象, 在和其他對象交互時,通過中介者來完成, 外觀模式是一結構型模式, 中介者模式是一行為性模式 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Facade package facade import \"fmt\" // 外觀類別, 她需要了解所有的子系統的方法或屬性, 並進行組合, 以備外界調用 type Facade struct { One SubSystemOne Two SubSystemTwo Three SubSystemThree Four SubSystemFour } func NewFacade() *Facade { return &Facade{SubSystemOne{}, SubSystemTwo{}, SubSystemThree{}, SubSystemFour{}} } func (f *Facade) MethodA() { fmt.Println(\"方法組 A\") f.One.MethodOne() f.Three.MethodThree() } func (f *Facade) MethodB() { fmt.Println(\"方法組 B\") f.Two.MethodTwo() f.Four.MethodFour() } type SubSystemOne struct { } func (s *SubSystemOne) MethodOne() { fmt.Println(\"子系統方法一\") } type SubSystemTwo struct { } func (s *SubSystemTwo) MethodTwo() { fmt.Println(\"子系統方法二\") } type SubSystemThree struct { } func (s *SubSystemThree) MethodThree() { fmt.Println(\"子系統方法三\") } type SubSystemFour struct { } func (s *SubSystemFour) MethodFour() { fmt.Println(\"子系統方法四\") } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"FactoryMethod/":{"url":"FactoryMethod/","title":"Factory Method","keywords":"","body":"Factory Method 工廠方法模式： 由次類別決定要建立的具象類別為何者 定義一個用於創建對象的接口，讓子類決定實例化哪一個類 是一種管理物件創建的模式，隨著輸入的參數不同，簡單工廠會回傳不同的物件 使用者取得物件的時候只要傳入正確的參數，不需要去理解這個物件 是一個使一個類的實例化延遲到其子類 所有應用簡單工廠的地方, 都可以老綠用反射技術來去除 switch 或 if 解除分支判斷帶來的耦合 Ex: 計算機 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/FactoryMethod /* Factory Method 工廠方法模式： 由次類別決定要建立的具象類別為何者 定義一個用於創建對象的接口，讓子類決定實例化哪一個類 是一種管理物件創建的模式，隨著輸入的參數不同，簡單工廠會回傳不同的物件 使用者取得物件的時候只要傳入正確的參數，不需要去理解這個物件 是一個使一個類的實例化延遲到其子類 此範例為 簡單工廠 */ package factorymethod type OperationFunc interface { SetNumA(float32) SetNumB(float32) GetNumA() float32 GetNumB() float32 GetResult() (float32, bool) } type Operation struct { numberA float32 numberB float32 } func (o *Operation) SetNumA(num float32) { if o == nil { return } o.numberA = num } func (o *Operation) SetNumB(num float32) { if o == nil { return } o.numberB = num } func (o *Operation) GetNumA() float32 { if o == nil { return 0 } return o.numberA } func (o *Operation) GetNumB() float32 { if o == nil { return 0 } return o.numberB } // 加法 type OperationAdd struct { Operation } func (o *OperationAdd) GetResult() (float32, bool) { if o == nil { return 0, false } return o.numberA + o.numberB, true } // 減 type OperationSub struct { Operation } func (o *OperationSub) GetResult() (float32, bool) { if o == nil { return 0, false } return o.numberA - o.numberB, true } // 乘 type OperationMul struct { Operation } func (o *OperationMul) GetResult() (float32, bool) { if o == nil { return 0, false } return o.numberA * o.numberB, true } // 除 type OperationDiv struct { Operation } func (o *OperationDiv) GetResult() (float32, bool) { if o == nil { return 0, false } if o.numberB == 0 { return 0, false } return o.numberA / o.numberB, true } // 建立工廠 type OperationFactory struct { oper string } func (of *OperationFactory) createoperation(op string) OperationFunc { switch op { case \"+\": return &OperationAdd{} case \"-\": return &OperationSub{} case \"*\": return &OperationMul{} case \"/\": return &OperationDiv{} } return nil } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"FactoryMethod/SimplevsFactory/":{"url":"FactoryMethod/SimplevsFactory/","title":"Simplevs Factory","keywords":"","body":"簡單工廠 vs. 工廠方法 定義可滋生成物件的介面, 但讓子類別去決定該具現出哪一種類別的物件. 此模式讓類別將具現化程序交給子類別去處置 簡單工廠 最大優點在於工廠類別中包含了必要的邏輯判斷, 根據用戶端的選擇條件動態實體化相關的類別 對用戶端來說, 去除了與具體產品的依賴 但是違背了 開放封閉原則 工廠模式 用戶端需決定實體化哪一個工廠來實現運算類別, 選擇判斷的問題還是存在 工廠方法把簡單工廠的內部邏輯判斷移到了用戶端程式碼來進行 如果要加功能, 本來是改工廠類型, 現在是修改用戶端 是簡單工廠模式的進一步抽象. 缺點是每加一個產品就需要加一個產品工廠的類別, 增加額外的開發量 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/FactoryMethod/SimplevsFactory /* 簡單工廠 vs. 工廠方法 簡單工廠 最大優點在於工廠類別中包含了必要的邏輯判斷, 根據用戶端的選擇條件動態實體化相關的類別 對用戶端來說, 去除了與具體產品的依賴 但是違背了 開放封閉原則 工廠模式 用戶端需決定實體化哪一個工廠來實現運算類別, 選擇判斷的問題還是存在 工廠方法把簡單工廠的內部邏輯判斷移到了用戶端程式碼來進行 如果要加功能, 本來是改工廠類型, 現在是修改用戶端 是簡單工廠模式的進一步抽象. 缺點是每加一個產品就需要加一個產品工廠的類別, 增加額外的開發量 */ package simplevsfactory import \"fmt\" type NigtingaleInterface interface { Sweep() Wash() BuyRice() } type Nigtingale struct { } func (n *Nigtingale) Sweep() { fmt.Println(\"掃地\") } func (n *Nigtingale) Wash() { fmt.Println(\"洗衣\") } func (n *Nigtingale) BuyRice() { fmt.Println(\"買米\") } type Undergraduate struct { Nigtingale } type Volunteer struct { Nigtingale } type SimpleFactory struct { } func (s *SimpleFactory) CreateNightingale(factoryType string) NigtingaleInterface { var result NigtingaleInterface switch factoryType { case \"學男丁格爾的大學生\": result = new(Undergraduate) return result case \"社區義工\": result = new(Volunteer) return result } return nil } type IFactory interface { CreateNightingale() } type UndergraduateFactory struct{} func (u *UndergraduateFactory) CreateNightingale() NigtingaleInterface { return new(Undergraduate) } type VolunteerFactory struct{} func (u *VolunteerFactory) CreateNightingale() NigtingaleInterface { return new(Volunteer) } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Flyweight/":{"url":"Flyweight/","title":"Flyweight","keywords":"","body":"Flyweight 享元模式： 以共享機制有效地支援一大堆小規模的物件 運用共用技術有效地支援大量細粒度的物件 造成大量記憶體消耗時, 就應該考慮使用; 或者是物件的大多數狀態是外部狀態, 如果刪除物件的外部狀態, 那麼可以用相對較少的共用物件取代很多組物件, 此時可以考慮使用享元模式. 像是圍棋棋子物件可以減少到只有兩個實體. 開發一個可供多人註冊的部落格網站 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Flyweight package flyweight import \"fmt\" type Flyweight interface { Operation(int) } type ConcreteFlyweight struct { name string } func (c *ConcreteFlyweight) Operation(extrinsicState int) { if c == nil { return } fmt.Println(\"具體 Flyweight\", extrinsicState) } type UnsharedConcreteFlyweight struct { name string } func (c *UnsharedConcreteFlyweight) Operation(extrinsicState int) { if c == nil { return } fmt.Println(\"不共用的具體 Flyweight\", extrinsicState) } type FlyweightFactory struct { flyweights map[string]Flyweight } func NewFlyweightFactory() *FlyweightFactory { fwfactory := FlyweightFactory{make(map[string]Flyweight)} fwfactory.flyweights[\"X\"] = &ConcreteFlyweight{\"X\"} fwfactory.flyweights[\"Y\"] = &ConcreteFlyweight{\"Y\"} fwfactory.flyweights[\"Z\"] = &ConcreteFlyweight{\"Z\"} return &fwfactory } func (f *FlyweightFactory) Flyweight(name string) Flyweight { if f == nil { return nil } if _, ok := f.flyweights[name]; !ok { f.flyweights[name] = &ConcreteFlyweight{name} } return f.flyweights[name] } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Interpreter/":{"url":"Interpreter/","title":"Interpreter","keywords":"","body":"Interpreter 享元模式： 針對標的語言定義文法, 以及可解讀這個語句的解譯器 給定一個語言, 定義它的文法的一種表示, 並定義一個解譯器, 這個解譯器使用該表示來解釋語言中的句子 如果一種特定類型的問題發生的頻率夠高, 那麼可能就值得將該問題的各個實體表達為一個簡單語言中的句子. 這樣可以建構一個解譯器, 該解譯器透過解釋這些句子來解決問題. Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Interpreter package interpreter import \"fmt\" type Context struct { input string output string } func (c *Context) Input() string { if c == nil { return \"\" } return c.input } func (c *Context) SetInput(str string) { if c == nil { return } c.input = str } func (c *Context) Output() string { if c == nil { return \"\" } return c.output } func (c *Context) SetOutput(str string) { if c == nil { return } c.output = str } // 抽象運算式 type AbstractExpression interface { Interpret(*Context) } type TerminalExpression struct { } func (t *TerminalExpression) Interpret(context *Context) { if t == nil { return } fmt.Println(\"終端解譯器\") } type NonterminalExpression struct { } func (t *NonterminalExpression) Interpret(context *Context) { if t == nil { return } fmt.Println(\"非終端解譯器\") } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Iterator/":{"url":"Iterator/","title":"Iterator","keywords":"","body":"Iterator 迭代器模式: 無需知曉聚合物件的內部細節, 即可依序存取內含的每一個元素 提供一種方法依序存取一個聚合物件中各個元素, 而又不暴露該物件的內部表示 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Iterator package iterator type Iterator interface { First() interface{} Next() interface{} IsDone() bool CurrentItem() interface{} } type ConcreteIterator struct { // 定義一個具體聚集物件 aggregate *ConcreteAggregate current int } func NewConcreteIterator(aggregate *ConcreteAggregate) *ConcreteIterator { return &ConcreteIterator{aggregate, 0} } func (c *ConcreteIterator) First() interface{} { return c.aggregate.items[0] } func (c *ConcreteIterator) Next() interface{} { c.current++ if c.current = c.aggregate.Count() { return true } return false } func (c *ConcreteIterator) CurrentItem() interface{} { if c == nil { return nil } return c.aggregate.items[c.current] } type Aggregate interface { CreateIterator() } type Object struct { Name string } type ConcreteAggregate struct { items []Object } func NewConcreteAggregate() *ConcreteAggregate { return new(ConcreteAggregate) } func (c *ConcreteAggregate) Count() int { return len(c.items) } func (c *ConcreteAggregate) GetThis(index int) Object { if c == nil { return Object{} } return c.items[index] } // SetThis : Insert 到指定 index func (c *ConcreteAggregate) SetThis(index int, val Object) { if c == nil { return } // 先要一組記憶體空間 tmpObject := Object{} c.items = append(c.items, tmpObject) copy(c.items[index+1:], c.items[index:]) c.items[index] = val } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Mediator/":{"url":"Mediator/","title":"Mediator","keywords":"","body":"Mediator 仲介者模式: 定義可將一群物件互動方式封裝起來的物件. 因為物件彼此不直接相互指涉, 所以耦合性低, 容易逐一變更互動關係 用一個仲介物件來封裝一系列的物件互動. 仲介者使各個物件不需要顯示地互相參考, 從而使其耦合鬆散, 而可以獨立低改變他們之間的互動 如果不存在擴展情況, Mediator 可以與 ConcreteMediator合二為一; 當系統出現了\"多對多\"互動複查的物件群時, 不要急著使用仲介者模式. 仲介者模式一般應用於一組物件以定義良好但是複雜的方式進行通訊的場合, 以及想訂製一個分布在多個類別中的行為, 而又不想產生太多子類別的場合 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Mediator package mediator import \"fmt\" // 定義一個抽象的發送消息方法, 得到同事物件和發送資訊 type IMediator interface { Send(string, IColleague) } type Mediator struct { } // 如果不存在擴展情況, Mediator 可以與 ConcreteMediator 合二為一 type ConcreteMediator struct { concreteColleague []IColleague } func NewConcreteMediator() *ConcreteMediator { return &ConcreteMediator{} } func (cm *ConcreteMediator) AddColleague(c IColleague) { if cm == nil { return } cm.concreteColleague = append(cm.concreteColleague, c) } func (cm *ConcreteMediator) Send(message string, colleague IColleague) { if cm == nil { return } for _, val := range cm.concreteColleague { if colleague == val { continue } val.Notify(message) } } // 抽象同事類別 type IColleague interface { Send(string) Notify(string) } type Colleague struct { mediator IMediator } type ConcreteColleague1 struct { Colleague } func NewConcreteColleague1(mediator IMediator) *ConcreteColleague1 { return &ConcreteColleague1{Colleague{mediator}} } func (c *ConcreteColleague1) Send(message string) { if c == nil { return } c.mediator.Send(message, c) } func (c *ConcreteColleague1) Notify(message string) { if c == nil { return } fmt.Println(\"同事1 得到訊息\", message) } type ConcreteColleague2 struct { Colleague } func NewConcreteColleague2(mediator IMediator) *ConcreteColleague2 { return &ConcreteColleague2{Colleague{mediator}} } func (c *ConcreteColleague2) Send(message string) { if c == nil { return } c.mediator.Send(message, c) } func (c *ConcreteColleague2) Notify(message string) { if c == nil { return } fmt.Println(\"同事2 得到訊息\", message) } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Memento/":{"url":"Memento/","title":"Memento","keywords":"","body":"Memento 備忘錄模式: 在不違反封裝性的前提下, 捕捉物件的內部狀態並存在外面,以便日後回復至此一狀態 在不破壞封裝性的前提下, 捕獲一個物件的內容狀態, 並在該物件之外保存這個狀態. 這樣以後就可以將該物件恢復到原先保存的狀態 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Memento package memento import \"fmt\" // GameRole: 遊戲角色, 發起人 Originator type GameRole struct { Vit int Atk int Def int } func (g *GameRole) InitState() { if g == nil { return } g.Vit = 100 g.Atk = 100 g.Def = 100 } func (g *GameRole) Fight() { if g == nil { return } g.Vit = 0 g.Atk = 0 g.Def = 0 } func (g *GameRole) StateDisplay() { if g == nil { return } fmt.Println(\"當前狀態：\") fmt.Println(\"生命力 : \", g.Vit) fmt.Println(\"攻擊力 :\", g.Atk) fmt.Println(\"防禦力 :\", g.Def) } // 保存角色狀態 func (g *GameRole) SaveState() RoleStateMemento { if g == nil { return RoleStateMemento{} } return RoleStateMemento{g.Vit, g.Atk, g.Def} } func (g *GameRole) RecoveryState(memento RoleStateMemento) { if g == nil { return } g.Vit = memento.Vitality() g.Atk = memento.Attack() g.Def = memento.Defense() } // RoleStateMemento : 角色狀態儲存箱, 備忘錄 Memento type RoleStateMemento struct { vit int atk int def int } func (r *RoleStateMemento) Vitality() int { if r == nil { return 0 } return r.vit } func (r *RoleStateMemento) Attack() int { if r == nil { return 0 } return r.atk } func (r *RoleStateMemento) Defense() int { if r == nil { return 0 } return r.def } // 角色狀態管理員 Caretaker type RoleStateCaretaker struct { memento RoleStateMemento } func (rc *RoleStateCaretaker) Memento() RoleStateMemento { if rc == nil { return RoleStateMemento{} } return rc.memento } func (rc *RoleStateCaretaker) SetMemento(m RoleStateMemento) { if rc == nil { return } rc.memento = m } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Observer/":{"url":"Observer/","title":"Observer","keywords":"","body":"Observer 觀察者模式: 定義一對多的物件依存關係, 讓物件狀態一有變動, 就自動通知其他相依物件做該做的更新動作 定義了一種一對多的依賴關係, 讓多個觀察者物件同時監聽某一個主題物件. 這主題物件在狀態發生變化時,會通知所有觀察者物件, 使他們能夠自動更新自己 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Observer package observer import \"fmt\" // 抽象通知者 or 主題 type Subject interface { Attach(Observer) Detach(Observer) Notify() State() int SetState(int) } type ConcreteSubject struct { subjectState int observers []*Observer } func (c *ConcreteSubject) Attach(o Observer) { if c == nil { return } for _, val := range c.observers { // 如果有訂閱 就不用在訂閱了 if *val == o { fmt.Println(\"有訂閱 就不用在訂閱了\") return } } c.observers = append(c.observers, &o) } func (c *ConcreteSubject) Detach(o Observer) { if c == nil { return } for key, val := range c.observers { // 有找到訂閱, 將其移除 if *val == o { // fmt.Println(\"detach\", (*val)) c.observers = append(c.observers[:key], c.observers[key+1:]...) } } } func (c *ConcreteSubject) Notify() { if c == nil { return } for _, val := range c.observers { (*val).Update() } } func (c *ConcreteSubject) State() int { if c == nil { return 0 } return c.subjectState } func (c *ConcreteSubject) SetState(state int) { if c == nil { return } c.subjectState = state } // 抽象觀察者 type Observer interface { Update() } type ConcreteObserver struct { name string subject Subject observerState int } func (c *ConcreteObserver) Update() { c.observerState = c.subject.State() fmt.Printf(\"觀察者 %s 的最新狀態是 %d \\n\", c.name, c.observerState) } func NewObserver(name string, subj Subject, state int) *ConcreteObserver { return &ConcreteObserver{name, subj, state} } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Prototype/":{"url":"Prototype/","title":"Prototype","keywords":"","body":"Prototype 原型模式： 制定可用原型個體生成的物件類型, 爾後只需複製此原型即可生成新物件 用原型實例指定建立物件的種類, 並且透過拷貝這些原型建立新的物件 從一個物件在建立另一個可訂製的物件,而且不需知道任何建立的細節 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Prototype /* Prototype 原型模式：用原型實例指定建立物件的種類, 並且透過拷貝這些原型建立新的物件 從一個物件在建立另一個可訂製的物件,而且不需知道任何建立的細節 */ package prototype import \"fmt\" type WorkExperience struct { workDate string company string } func (w *WorkExperience) GetWorkDate() string { return w.workDate } func (w *WorkExperience) SetWorkDate(val string) { w.workDate = val } func (w *WorkExperience) GetCompany() string { return w.company } func (w *WorkExperience) SetCompany(val string) { w.company = val } func (w *WorkExperience) Clone() *WorkExperience { if w == nil { return nil } // 淺複製, 複製結構, 但不複製值 shallowObj := w fmt.Printf(\"&shallowObj: %p, orgObj: %p , shallowObj: %+v \\n\", &shallowObj, w, shallowObj) return shallowObj } type Resume struct { name string sex string age string work WorkExperience } // NewResume 建構值 func NewResume(n string) *Resume { work := WorkExperience{} return &Resume{name: n, work: work} } // 提供clone 方法呼叫的私有建構是, 以便複製工作經歷的資料 func (r *Resume) cloneWork(w WorkExperience) { r.work = *w.Clone() } // SetPersonalInfo 設定個人資訊 func (r *Resume) SetPersonalInfo(sex, age string) { if r == nil { return } r.age = age r.sex = sex } // SetWorkExperience 設定工作經歷 func (r *Resume) SetWorkExperience(workDate, company string) { if r == nil { return } r.work.company = company r.work.workDate = workDate } // Display 顯示履歷 func (r *Resume) Display() { if r == nil { return } fmt.Println(r.name, r.sex, r.age) fmt.Println(\"工作經歷: \", r.work.workDate, r.work.company) } // Clone 深複製履歷 // 淺複製: 被複製物件的所有變數都含有與原來的物件相同的值, 而所有的對其物件的參考都能指向 // 深複製: 把參考物件的變數指向複製過的新物件, 而不是原有他被參考的物件 func (r *Resume) Clone() *Resume { // 深複製 // var obj = new(Resume) // obj.work = *(r.work).Clone() // obj.age = r.age // obj.name = r.name // obj.sex = r.sex // return obj // 淺複製 : 會導致來源的值也被更改 shallowObj := r shallowObj.age = r.age shallowObj.name = r.name shallowObj.sex = r.sex shallowObj.work = *(r.work).Clone() return shallowObj } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Proxy/":{"url":"Proxy/","title":"Proxy","keywords":"","body":"Proxy 代理模式： 替其他物件預留代理者空位, 就此控制存取其他物件 將物件包裝起來, 以控制對此物件的存取 為其他物件提供一種代理, 以控制對這個物件的存取 代理和代理的對象接口一致，客户端不知道代理對象 代理 vs. 外觀 代理物件代表一個單一物件, 而外觀物件代表一個子系統. 代理的客戶無法直接存取目標物件, 由代理提供的對單獨之目標物件的存取控制, 而外觀的客戶物件可以直接存取子系統中的各個物件, 但通常由外觀物件提供對子系統各元件功能的簡化的共同層次的調用介面 代理 vs. 轉接器 都屬於一種銜接性質的功能. 代理是一種原來物件的代表, 其他需要與這個物件打交道的操作都是和這個代表交涉 轉接器則不需要虛構出一個代表者, 只需要為應付特定使用目的, 將原來的類別進行一些組合 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Proxy /* Proxy 代理模式： 將物件包裝起來, 以控制對此物件的存取 為其他物件提供一種代理, 以控制對這個物件的存取 代理和代理的對象接口一致，客户端不知道代理對象 */ package proxy import \"fmt\" // IGiveGift : Subject type IGiveGift interface { GiveDolls() GiveFlowers() GiveChocolate() } type SchoolGirl struct { name string } func (g *SchoolGirl) Name() string { if g == nil { return \"\" } return g.name } func (g *SchoolGirl) SetName(name string) { if g == nil { return } g.name = name } // Pursuit : real subject type Pursuit struct { girl SchoolGirl } func (p *Pursuit) GiveDolls() { if p == nil { return } fmt.Println(p.girl.name, \"送你洋娃娃\") } func (p *Pursuit) GiveFlowers() { if p == nil { return } fmt.Println(p.girl.name, \"送你鮮花\") } func (p *Pursuit) GiveChocolate() { if p == nil { return } fmt.Println(p.girl.name, \"送你巧克力\") } // Proxy Proxy type Proxy struct { pursuit Pursuit } func NewProxy(girl SchoolGirl) *Proxy { pursuit := Pursuit{girl} return &Proxy{pursuit} } func (p *Proxy) GiveDolls() { if p == nil { return } p.pursuit.GiveDolls() } func (p *Proxy) GiveFlowers() { if p == nil { return } p.pursuit.GiveFlowers() } func (p *Proxy) GiveChocolate() { if p == nil { return } p.pursuit.GiveChocolate() } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Singleton/":{"url":"Singleton/","title":"Singleton","keywords":"","body":"Singleton 獨體模式： 確保類別只會有一個物件實體存在, 並提供單一存取窗口 保證一個類別僅有一個實體, 並提供一個存取它的全域訪問點 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Singleton package singleton import \"sync\" type Singleton struct { } // 方法一: \b用 sync.Mutex var instance *Singleton var mu sync.Mutex func GetInstance() *Singleton { if instance != nil { mu.Lock() defer mu.Unlock() if instance != nil { instance = &Singleton{} } } return instance } // 方法二: \b用 sync.Once var once sync.Once func GetInstanceOnce() *Singleton { once.Do(func() { instance = &Singleton{} }) return instance } Benchmark goos: darwin goarch: amd64 pkg: DesignPatternGolang/Singleton cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkSingleton-4 401843040 2.971 ns/op 0 B/op 0 allocs/op BenchmarkSingletonOnce-4 581861808 2.129 ns/op 0 B/op 0 allocs/op PASS ok DesignPatternGolang/Singleton 2.960s © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"State/":{"url":"State/","title":"State","keywords":"","body":"State 狀態模式: 讓物件的外顯行為隨內部狀態的改變而改變, 彷彿連類別也變了似的 當一個物件的內在狀態改變時, 允許改變其行為, 這個物件看起來像是改變了其類別 主要解決的是當控制一個物件狀態轉換的條件運算式過於複雜的情況. 把狀態的判斷邏輯轉移到表示不同狀態的一系列類別中, 可以把複雜的判斷邏輯簡化 State 的 UML 與策略模式相似 Strategy 策略模式：: 是用在對多個做同樣事情（統一接口）的類對象的選擇上 State 狀態模式: 將對某個事情的處理過程抽象成接口和實現類的形式， 由context保存一份state，在state實現類處理事情時，修改狀態傳遞給context， 由context繼續傳遞到下一個狀態處理中， Example https://github.com/kimi0230/DesignPatternGolang/tree/master/State package state import \"fmt\" // 工作類別 type Work struct { current State hour int finish bool } func NewWork() *Work { return &Work{current: new(ForenoonState)} } func (w *Work) Hour() int { if w == nil { return -1 } return w.hour } func (w *Work) State() State { if w == nil { return nil } return w.current } func (w *Work) Finish() bool { if w == nil { return false } return w.finish } func (w *Work) SetHour(h int) { if w == nil { return } w.hour = h } func (w *Work) SetState(s State) { if w == nil { return } w.current = s } func (w *Work) SetFinish(f bool) { if w == nil { return } w.finish = f } func (w *Work) WriteProgram() { if w == nil { return } w.current.WriteProgram(w) } type State interface { WriteProgram(*Work) } type ForenoonState struct{} func (f *ForenoonState) WriteProgram(w *Work) { if w.Hour() © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Strategy/":{"url":"Strategy/","title":"Strategy","keywords":"","body":"Strategy 策略模式： 定義一整組演算法, 講每一個演算法封裝起來, 可互換使用, 更可在不影響外界的情況下個別抽換所以引用的演算法 可以將互換的行為封裝起來, 並使用轉接方式決定要使用何者 用戶端實體化的事 CashContext 的物件, 調用的是 CashContext 的方法 GetResult 使具體的收費演算法測底與用戶端分離 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Strategy /* Strategy 策略模式： 講可以互換的行為封裝起來, 並使用專接方式決定要使用何者 用戶端實體化的事 CashContext 的物件, 調用的是 CashContext 的方法 GetResult 使具體的收費演算法測底與用戶端分離 */ package strategy import \"errors\" type CashSuper interface { acceptCash(memory float32) float32 } // CashNomal : 正常收費 type CashNomal struct { } func (this *CashNomal) acceptCash(money float32) float32 { return money } // CashRebate : 打折收費 // meneyRebate 折扣率 type CashRebate struct { meneyRebate float32 } func (this *CashRebate) acceptCash(money float32) float32 { return this.meneyRebate * money } // CashReturn : 紅利收費 // 比如滿300送100, meneyCondition=300, meneyReturn=100 type CashReturn struct { meneyCondition float32 meneyReturn float32 } func (this *CashReturn) acceptCash(money float32) float32 { if money >= this.meneyCondition { return money - float32(int(money/this.meneyCondition))*this.meneyReturn } else { return money } } type CashContext struct { CashSuper } func (cc *CashContext) CashContext(str string) error { switch str { case \"正常收費\": cc.CashSuper = &CashNomal{} case \"滿300送100\": cc.CashSuper = &CashReturn{300, 100} case \"打8折\": cc.CashSuper = &CashRebate{0.8} default: err := errors.New(\"no match\") return err } return nil } func (cc *CashContext) GetResult(money float32) float32 { return cc.acceptCash(money) } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"TemplateMethod/":{"url":"TemplateMethod/","title":"Template Method","keywords":"","body":"Template Method 範本方式模式: 由次類別決定如何實現一個演算法中的步驟 對於操作, 只先定義好演算法的輪廓, 某些步驟則留給子類別去填飽, 以便在不改變演算法整體構造的情況下讓子類別去精煉某些步驟 定義一個操作中的演算法的骨架, 而將一些步驟延遲到子類別中. 範本方式使得子類別可以不改變一個演算法的結構即可重定義該演算法的某些特定步驟 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/TemplateMethod /* Template Method 範本方式模式: 由次類別決定如何實現一個演算法中的步驟 定義一個操作中的演算法的骨架, 而將一些步驟延遲到子類別中. 範本方式使得子類別可以不改變一個演算法的結構即可重定義該演算法的某些特定步驟 */ package templatemethod import \"fmt\" type AbstractClass interface { // 一些抽象行為, 放到子類別去實現 PrimitiveOperation1() PrimitiveOperation2() } type template struct { abstractClass AbstractClass } // TemplateMethod : 範本function 給出了邏輯的骨架 // 而邏輯的組成是一些相應的抽象操作 // 他們都推遲到子類別實現 func (t *template) TemplateMethod() { if t == nil { return } t.abstractClass.PrimitiveOperation1() t.abstractClass.PrimitiveOperation2() } type concreteClassA struct { template } func NewClassA() *concreteClassA { classA := concreteClassA{} return &classA } func (a *concreteClassA) PrimitiveOperation1() { fmt.Println(\"具體類別A方法1實現\") } func (a *concreteClassA) PrimitiveOperation2() { fmt.Println(\"具體類別A方法2實現\") } type concreteClassB struct { template } func NewClassB() *concreteClassB { classB := concreteClassB{} return &classB } func (b *concreteClassB) PrimitiveOperation1() { fmt.Println(\"具體類別B方法1實現\") } func (b *concreteClassB) PrimitiveOperation2() { fmt.Println(\"具體類別B方法2實現\") } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"Visitor/":{"url":"Visitor/","title":"Visitor","keywords":"","body":"Visitor 訪問者模式: 定義能逐一施行於物件結構裡各個元素的操作, 讓你不必修改作用對象的類別介面, 就能定義新的操作 表示一個作用於某物件結構中的各元素之操作. 他使你可以在不改變各元素之類別的前提下, 定義作用於這些元素的新操作 訪問者增加具體的 Element 是困難的, 但增加依賴於複雜物件結構的構建的操作就變得容易. 僅需要增加一個新的訪問者, 即可在一個物件結構上定義一個新操作 Example https://github.com/kimi0230/DesignPatternGolang/tree/master/Visitor package visitor import \"fmt\" type Visitor interface { VisitConcreteElementA(ConcreteElementA) VisitConcreteElementB(ConcreteElementB) } type ConcreteVisitorA struct { } func (c *ConcreteVisitorA) VisitConcreteElementA(ele ConcreteElementA) { if c == nil { return } ele.OperatorA() } func (c *ConcreteVisitorA) VisitConcreteElementB(ele ConcreteElementB) { if c == nil { return } ele.OperatorB() } type ConcreteVisitorB struct { } func (c *ConcreteVisitorB) VisitConcreteElementA(ele ConcreteElementA) { if c == nil { return } ele.OperatorA() } func (c *ConcreteVisitorB) VisitConcreteElementB(ele ConcreteElementB) { if c == nil { return } ele.OperatorB() } type Element interface { Accept(Visitor) } type ConcreteElementA struct{} func (c *ConcreteElementA) Accept(visitor Visitor) { if c == nil { return } visitor.VisitConcreteElementA(*c) } func (c *ConcreteElementA) OperatorA() { if c == nil { return } fmt.Println(\"OperatorA\") } type ConcreteElementB struct{} func (c *ConcreteElementB) Accept(visitor Visitor) { if c == nil { return } visitor.VisitConcreteElementB(*c) } func (c *ConcreteElementB) OperatorB() { if c == nil { return } fmt.Println(\"OperatorB\") } type ObjectStructure struct { elemetes []Element } func (o *ObjectStructure) Attach(ele Element) { if o == nil || ele == nil { return } o.elemetes = append(o.elemetes, ele) } func (o *ObjectStructure) Detach(ele Element) { if o == nil || ele == nil { return } for i, val := range o.elemetes { if val == ele { o.elemetes = append(o.elemetes[:i], o.elemetes[i+1:]...) break } } } func (o *ObjectStructure) Accept(v Visitor) { if o == nil { return } for _, val := range o.elemetes { val.Accept(v) } } © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © Kimi Tsai all right reserved.            Updated : 2022-09-30 06:29:46 "}}